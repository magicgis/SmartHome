<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Plugin</name>
    </assembly>
    <members>
        <member name="T:Plugin.MessageListenedDelegate">
            <summary>
            A delegate for the MessageListened Event of the Debug Class
            </summary>
            <param name="channel">The identifier of the sending debug channel</param>
            <param name="message">The logged message</param>
        </member>
        <member name="T:Plugin.EventDelegate">
            <summary>
            A delegate with no parameters
            </summary>
        </member>
        <member name="T:Plugin.Debug">
            <summary>
            Provides functionality for logging information
            </summary>
        </member>
        <member name="E:Plugin.Debug.MessageListened">
            <summary>
            Gets called if a new message is beeing logged and the channel is enabled
            </summary>
        </member>
        <member name="E:Plugin.Debug.ChannelsChanged">
            <summary>
            Gets called if the list of registered channels has changed
            </summary>
        </member>
        <member name="E:Plugin.Debug.EnabledChannelsChanged">
            <summary>
            Gets called if the list of enabled channels has changed
            </summary>
        </member>
        <member name="E:Plugin.Debug.DisabledChannelsChanged">
            <summary>
            Gets called if the list of disabled channels has changed
            </summary>
        </member>
        <member name="P:Plugin.Debug.Cache">
            <summary>
            Empty if caching is disabled
            Contains all logged messages since caching is enabled
            </summary>
        </member>
        <member name="M:Plugin.Debug.EnableCaching">
            <summary>
            Enabled Caching. This will clear the cache. Cached messaged will be stored in <see cref="P:Plugin.Debug.Cache"/>
            </summary>
        </member>
        <member name="M:Plugin.Debug.DisableCaching">
            <summary>
            Disables Caching. This will clear the cache. Cached messaged will be stored in <see cref="P:Plugin.Debug.Cache"/>
            </summary>
        </member>
        <member name="P:Plugin.Debug.Channels">
            <summary>
            A readonly collection of registered channels
            </summary>
        </member>
        <member name="P:Plugin.Debug.EnabledChannels">
            <summary>
            A readonly collection of enabled channels
            </summary>
        </member>
        <member name="P:Plugin.Debug.DisabledChannels">
            <summary>
            A readonly collection of disabled channels
            </summary>
        </member>
        <member name="M:Plugin.Debug.AddChannel(System.String)">
            <summary>
            Registers a new channel for use
            </summary>
            <param name="name">The name of the channel</param>
            <returns>The int identifier of the channel for function calls. -1 if failed</returns>
        </member>
        <member name="M:Plugin.Debug.DeleteChannel(System.Int32)">
            <summary>
            Deletes a channel
            </summary>
            <param name="channel">The int identifier of the channel</param>
        </member>
        <member name="M:Plugin.Debug.GetChannelName(System.Int32)">
            <summary>
            Returns to corresponding channel name of a identifier
            </summary>
            <param name="channel">The channels identifier</param>
            <returns>The channels name. Null if failed</returns>
        </member>
        <member name="M:Plugin.Debug.GetChannelId(System.String)">
            <summary>
            Returns the assigned channel id of a registered channel
            </summary>
            <param name="name">The channels name</param>
            <returns>The id of the channel. -1 if not registered</returns>
        </member>
        <member name="M:Plugin.Debug.EnableChannel(System.Int32)">
            <summary>
            Enabled a channel. Enabled channels messages will get logged
            </summary>
            <param name="channel">The channel identifier</param>
        </member>
        <member name="M:Plugin.Debug.DisableChannel(System.Int32)">
            <summary>
            Disables a channel. Disabled channels messages will not get logged
            </summary>
            <param name="channel">The channel identifier</param>
        </member>
        <member name="M:Plugin.Debug.Log(System.Int32,System.String)">
            <summary>
            Loggs a message. The message will only cause the MessageListened event to occur if the calling channel is enabled
            </summary>
            <param name="channel">The calling channel</param>
            <param name="message">The channels message</param>
        </member>
        <member name="T:Plugin.DisplayPlugin">
            <summary>
            Base class for all display plugins that provide GUI
            </summary>
        </member>
        <member name="P:Plugin.DisplayPlugin.Control">
            <summary>
            The visible control of the plugin. This control will get its own tab page and gets DockStyle.Fill at startup
            </summary>
        </member>
        <member name="P:Plugin.DisplayPlugin.TabName">
            <summary>
            The visible name of the tab page
            </summary>
        </member>
        <member name="M:Plugin.DisplayPlugin.OnControlLoad">
            <summary>
            This method will get called when the plugins control is loaded
            </summary>
        </member>
        <member name="M:Plugin.DisplayPlugin.OnControlUnload">
            <summary>
            This method will get called when the plugins control is unloaded
            </summary>
        </member>
        <member name="M:Plugin.DisplayPlugin.OnControlInvisible">
            <summary>
            This method will get called when the plugins control gets invisible
            </summary>
        </member>
        <member name="M:Plugin.DisplayPlugin.OnControlVisible">
            <summary>
            This metod will get called when the plugins control gets visible
            </summary>
        </member>
        <member name="T:Plugin.FunctionInfo">
            <summary>
            Provides info and functionality for calling reflected methods
            </summary>
        </member>
        <member name="P:Plugin.FunctionInfo.Name">
            <summary>
            A custom name of the function
            </summary>
        </member>
        <member name="P:Plugin.FunctionInfo.Instance">
            <summary>
            The instance that will get invoked
            </summary>
        </member>
        <member name="M:Plugin.FunctionInfo.#ctor(System.String,System.Object,System.Reflection.MethodInfo)">
            <summary>
            Creates a new instance
            </summary>
            <param name="name">A custom name</param>
            <param name="instance">The instance to call the function on</param>
            <param name="info">The function info itself</param>
        </member>
        <member name="P:Plugin.FunctionInfo.Parameters">
            <summary>
            Returns a list with parameter names
            </summary>
        </member>
        <member name="M:Plugin.FunctionInfo.GetParameterType(System.String)">
            <summary>
            Returns the type of a specific parameter
            </summary>
            <param name="parameter">The parameter</param>
            <returns>The return type</returns>
        </member>
        <member name="P:Plugin.FunctionInfo.ReturnType">
            <summary>
            Returns the returntype
            </summary>
        </member>
        <member name="M:Plugin.FunctionInfo.Invoke(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Invokes the method with a given parameter set
            </summary>
            <param name="parameters">The parameters</param>
            <returns>The methods return value</returns>
        </member>
        <member name="T:Plugin.NeedsPlugin">
            <summary>
            Should only be applied to Plugin classed
            
            This attribute tells the plugin system, that another plugin is required for this plugin to work.
            This plugin will not be loaded, if the required plugin is not loaded.
            At startup, this plugin will wait
            At runtime, the loading process will be canceled
            </summary>
        </member>
        <member name="P:Plugin.NeedsPlugin.NeededPlugin">
            <summary>
            The name of the needed plugin
            </summary>
        </member>
        <member name="M:Plugin.NeedsPlugin.#ctor(System.String)">
            <summary>
            Constructor of NeedsPlugin
            </summary>
            <param name="neededPlugin">The name of the needed plugin</param>
        </member>
        <member name="T:Plugin.NetworkFunction">
            <summary>
            A network function can get called from the network manager
            </summary>
        </member>
        <member name="P:Plugin.NetworkFunction.Name">
            <summary>
            The custom name of the function
            </summary>
        </member>
        <member name="M:Plugin.NetworkFunction.#ctor(System.String)">
            <summary>
            Creates a new instance of the attribute
            </summary>
            <param name="name">The custom name of the function</param>
        </member>
        <member name="T:Plugin.NetworkManager">
            <summary>
            Manages all network stuff
            </summary>
        </member>
        <member name="E:Plugin.NetworkManager.NetworkFunctionsChanged">
            <summary>
            Gets called if a network function is registered or unregistered
            </summary>
        </member>
        <member name="M:Plugin.NetworkManager.Init">
            <summary>
            Initializes the manager
            </summary>
        </member>
        <member name="M:Plugin.NetworkManager.Close">
            <summary>
            Closes the networkmanager
            </summary>
        </member>
        <member name="P:Plugin.NetworkManager.NetworkFunctions">
            <summary>
            A readonly collection of network functions
            </summary>
        </member>
        <member name="M:Plugin.NetworkManager.GetNetworkFunction(System.String)">
            <summary>
            Returns the corresponding network function to the custom name
            </summary>
            <param name="name">The network functions name</param>
            <returns>FunctionInfo of the network function</returns>
        </member>
        <member name="M:Plugin.NetworkManager.RegisterNetworkFunction(Plugin.FunctionInfo)">
            <summary>
            Registers a networkfunction so it can get called
            </summary>
            <param name="info">The functions info</param>
        </member>
        <member name="M:Plugin.NetworkManager.UnregisterNetworkFunction(System.String)">
            <summary>
            Unregisteres a networkfunction so it cant get called anymore
            </summary>
            <param name="name">The functions info</param>
        </member>
        <member name="T:Plugin.Plugin">
            <summary>
            Base class for all custom plugins that get loaded dynamically at runtime
            </summary>
        </member>
        <member name="P:Plugin.Plugin.Name">
            <summary>                                      
            The display name of the plugin. This will also be used for identification
            </summary>
        </member>
        <member name="P:Plugin.Plugin.Version">
            <summary>
            The current version of the plugin
            </summary>
        </member>
        <member name="P:Plugin.Plugin.DataDir">
            <summary>
            Provides the path to a plugin specific directory to save data
            </summary>
        </member>
        <member name="P:Plugin.Plugin.GetDatabaseConnection">
            <summary>
            Returns a MySqlConnection for the plugins specific database
            </summary>
        </member>
        <member name="M:Plugin.Plugin.OnPluginLoad">
            <summary>
            This method will get called when this plugin is loaded. It is not guaranteed that other plugins already are loaded too
            </summary>
        </member>
        <member name="M:Plugin.Plugin.OnPluginsLoad">
            <summary>
            This method will get called once loading all plugins is finished 
            </summary>
        </member>
        <member name="M:Plugin.Plugin.OnPluginsUnload(System.Collections.Generic.List{System.String})">
            <summary>
            This method will get called if the plugin system attempts to unload one or more plugins. At call time no plugin is unloaded
            <param name="plugins">A list of plugins that is going to be unloaded</param>
            </summary>
        </member>
        <member name="M:Plugin.Plugin.OnPluginUnload">
            <summary>
            This method will get called once this plugin gets unloaded. It is not guaranteed that other plugins are loaded any more
            </summary>
        </member>
        <member name="T:Plugin.PluginChangeDelegate">
            <summary>
            A delegate for the <see cref="E:Plugin.PluginManager.PluginUnload"/> event
            </summary>
            <param name="plugin">The plugin that will be unloaded</param>
        </member>
        <member name="T:Plugin.PluginManager">
            <summary>
            The pluginmanager manages the loading/unloading and the already loaded plugins for the application
            </summary>
        </member>
        <member name="E:Plugin.PluginManager.PluginUnload">
            <summary>
            Gets called if a plugin gets unloaded so everyone can react to it
            </summary>
        </member>
        <member name="E:Plugin.PluginManager.PluginLoad">
            <summary>
            Gets called if a plugin gets loaded so everyone can react to it
            </summary>
        </member>
        <member name="P:Plugin.PluginManager.Plugins">
            <summary>
            A readonly collection of currenty loaded plugins
            </summary>
        </member>
        <member name="P:Plugin.PluginManager.DisplayPlugins">
            <summary>
            A readonly collection of currently loaded display plugins
            </summary>
        </member>
        <member name="M:Plugin.PluginManager.GetPlugin(System.String)">
            <summary>
            Returns the plugin with a specific name
            </summary>
            <param name="plugin">The plugins name</param>
            <returns>The found plugin or null if not found</returns>
        </member>
        <member name="M:Plugin.PluginManager.LoadFromDir(System.IO.DirectoryInfo)">
            <summary>
            Loads all plugins in the specified directory
            </summary>
            <param name="dir">The target directory</param>
        </member>
        <member name="M:Plugin.PluginManager.UnloadAll">
            <summary>
            Unloads all plugins
            </summary>
        </member>
        <member name="M:Plugin.PluginManager.LoadFromDir(System.IO.DirectoryInfo,System.Collections.Generic.List{System.Type}@)">
            <summary>
            Loads all plugins in a directory
            </summary>
            <param name="dir">The DirectoryInfo for the destination directory</param>
            <param name="unloadablePlugins">Contains a List of plugins that could not be loaded</param>
            <returns>A List of loaded plugins</returns>
        </member>
        <member name="M:Plugin.PluginManager.LoadTypes(System.IO.DirectoryInfo)">
            <summary>
            Loads all types from all files in a dir
            </summary>
            <param name="dir">The DirectoryInfo for the destination directory</param>
            <returns>A List of types</returns>
        </member>
        <member name="M:Plugin.PluginManager.NeededPluginsLoaded(System.Type,System.Collections.Generic.List{Plugin.Plugin})">
            <summary>
            Checks if all of a plugins needed plugins are already loaded.
            
            Will return true if the type is no subclass of Plugin or does not have any NeedsPlugin attributes
            </summary>
            <param name="plugin">The plugin to check</param>
            <param name="plugins">A temporary list of already loaded plugins</param>
            <returns>True if all required plugins are already loaded. Otherwise false</returns>
        </member>
        <member name="M:Plugin.PluginManager.PluginLoaded(System.String,System.Collections.Generic.List{Plugin.Plugin})">
            <summary>
            Checks if a plugin is already loaded
            </summary>
            <param name="plugin">The name of the plugin to check</param>
            <param name="plugins">A temporary list of already loaded plugins</param>
            <returns>True if the plugins is already loaded. Otherwise false</returns>
        </member>
        <member name="T:Plugin.Semaphore">
            <summary>
            Helps managing function calls in multithreaded environments
            </summary>
        </member>
        <member name="F:Plugin.Semaphore._queue">
            <summary>
            A queue of waiting operations
            </summary>
        </member>
        <member name="M:Plugin.Semaphore.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:Plugin.Semaphore.Enqueue">
            <summary>
            Tells the semaphore so wait until its the invokers turn
            </summary>
        </member>
        <member name="M:Plugin.Semaphore.Wait(System.Object)">
            <summary>
            Waits until its the specified objects turn
            </summary>
            <param name="obj">The waiting object</param>
        </member>
        <member name="M:Plugin.Semaphore.Dequeue">
            <summary>
            Tells the semaphore that the current object is done with its work
            </summary>
        </member>
    </members>
</doc>
